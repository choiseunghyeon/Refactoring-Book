## 캡슐화

- 단일 접근 원칙(Uniform access principle) - 무엇이 저장된 값이고 무엇이 계산된 값인지 알 필요 없이 하나의 메서드로 접근할 수 있다. 237p.
- 캡슐화를 하면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉽다.(메서드를 통해서 변경이 되기 때문에) 단, 게터를 통해 원본 데이터를 반환하면 어디서 수정되는지 파악하기 어려울 수 있다. 이것을 방지하기 위해 게터가 원본이 아닌 복사본을 반환하도록 한다.
- 캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 이로 인해 무언가 변경할 떄 고려해야 하는 부분이 적어져서 코드를 변경하기가 훨씬 쉬워진다.

## 리팩터링

- 레코드(객체) 캡슐화하기
- 컬렉션(배열) 캡슐화하기

- 기본형을 객체로 바꾸기
  - 악취 중 기본형 집착 - Primitive Obsession으로 숫자나 문자열 등 간단하게 표현하다가 포매팅이나 지역 코드 추출 같은 특별한 동작이 필요한 경우 수행한다.
  - 단순한 출력 이상의 기능이 필요해질 떄
- 임시 변수를 질의 함수로 바꾸기
  - 긴 함수의 부분을 함수로 추출할 때 임시 변수를 질의 함수로 바꾸면 추출한 함수에 변수를 따로 전달할 필요가 없어서 편하다. (여러 함수에서 가져다 쓸 수 있다.)
  - 클래스 안에서 적용할 때 효과가 크다.
  - 추출한 함수와 원래 함수의 경계가 분명해지기도 하는데, 부자연스러운 의존관계나 부수효과를 찾고 제거하는 데 도움이 된다.
- 클래스 추출하기
  - 추출 신호 (특정 데이터나 메서드 일부를 제거해도 다른 필드나 메서드들이 논리적으로 문제가 없다면 분리할 수 있다.)
  1. 일부 데이터와 메서드를 따로 묶을 수 있을 때
  2. 함께 변경되거나 서로 의존하는 데이터
  3. 작은 일부 기능을 위해 서브 클래스를 만들거나 확장해야할 기능에 따라 서브클래스를 만드는 방식이 달라질 때
- 클래스 인라인하기
  - 남은 역할이 거의 없을 때 이 클래스를 가장 많이 쓰는 클래스로 흡수
  - 두 클래스의 기능을 지금과 다르게 배분하고 싶을 때 인라인 해서 하나로 합친 다음 새로운 클래스로 추출하는게 쉬울 수도 있다.
- 위임 숨기기
  - 클래스 사이의 연결 관계를 숨기는데 유용
  - 클라이언트 입장에서 위임 객체의 세부 내용을 몰라도 된다.
- 중개자 제거하기
  - 클래스 사이의 연결 관계를 지나치게 숨기려다 보면 인터페이스가 비대해질 수 있다
- 알고리즘 교체하기
  - 리팩터링하면 복잡한 대상을 단순한 단위로 나눌 수 있지만 때로는 알고리즘 전체를 걷어내고 훨씬 간결한 알고리즘으로 바꿔야 할 때가 있다.
