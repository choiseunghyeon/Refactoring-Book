## TIP

- 서브 클래싱(상속)은 원래 데이터 구조와는 다른 변종을 만들거나 종류에 따라 동작이 달라지게 할 수 있는 유용한 메커니즘 - 다름을 프로그래밍하는 수단
- 무언가의 표현 방법을 바꿀 때는 캡슐화하여 이 변화가 클라이언트 코드에 주는 영향을 최소화 한다. - 서브클래스 만들기를 캡슐화하는 방법은 생성자를 팩터리 함수로 바꾸기다.
- 상속은 단점이 있다.
  1. 무언가 달라져야 하는 이유가 여러 개여도 상속에서는 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다. (사람 객체의 동작을 '나이대', '소득 수준'에 따라 달리 하고 싶다면 서브 클래스는 젊은이와 어르신이 되거나 부자와 서민이 되어야 한다. 둘 다는 안 된다.)
  2. 클래스들의 관계를 긴밀하게 결합한다. ( 부모를 수정하면 이미 존재하는 자식들의 기능을 해치기 쉽다.)
- 상속의 단점은 위임이 해결해준다.
- 슈퍼클래스의 기능들이 서브클래스에 어울리지 않는다면 그 기능들을 상속을 통해 이용하면 안된다는 신호다. / 제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다. 즉, 슈퍼클래스가 사용되는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야 한다.

## 특정 기능을 상속 계층구조의 위나 아래로 옮기기

- 메서드 올리기
  - 중복 코드 제거
  - 가장 쉬운 상황은 메서드들의 코드가 똑같을 때지만 메서드 본문에서 참조하는 필드가 서브클래스에만 있다면 필드 올리기를 수행하자.
  - 전체 흐름은 비슷하지만 세부 내용이 다르다면 템플릿 메서드 만들기(Form Template Method)를 고려하자.
- 필드 올리기
  - 중복 코드 제거 ( 데이터 중복 선언 없앨 수 있다. / 해당 필드를 사용하는 동작을 서브클래스에서 슈퍼클래스로 옮길 수 있다.)
  - 상황: 서브클래스들이 독립적으로 개발되었거나 뒤늦게 하나의 계층구조로 리팩터링된 경우라면 필드가 중복되기 쉽다.
- 생성자 본문 올리기
- 메서드 내리기
- 필드 내리기

## 계층 사이에 클래스를 추가하거나 제거

- 슈퍼클래스 추출하기
- 서브클래스 제거하기
  - 소프트웨어가 성장하며 서브클래스로 만든 변종이 다른 모듈로 이동하거나 사라지기도 하면서 가치가 바래기도 한다. 이럴 때는 서브클래스를 슈퍼클래스의 필드로 대체해 제거하자.
- 계층 합치기

  - 시간이 흘러 어떤 클래스와 부모가 너무 비슷해져서 더는 독립적으로 존재할 이유가 없이지기도 하는데 이럴 때는 합치자.

- 타입 코드를 서브클래스로 바꾸기
  - 필드 값에 따라 동작이 달라지는 코드가 있는데, 이런 필드를 서브 클래스로 대체하고 싶을 때
  - 조건에 따라 다르게 동작하도록 해주는 다형성 제공 / 특정 타입에서만 의미 있는 필드나 메서드를 구분할 수 있다.

## 상속은 막강한 도구지만, 잘못된 곳에서 사용되거나 환경이 변해 문제가 된다면 상속을 위임으로 바꿔준다.

- 서브클래스를 위임으로 바꾸기

  - 이 리팩터링을 상태 패턴(State Pattern)이나 전략 패턴(Strategy Pattern)으로 대체 한다고 봐도 된다. 구조적으로 보면 두 패턴은 똑같이 호스트 위임 방식으로 계층구조를 분리해준다.
  - 위임을 적용하면 분배 로직과 양방향 참조가 더해지는 등 복잡도가 높이지지만 동적으로 객체를 바꿀 수 있고 상속은 다른 목적으로 사용할 수 있게 된다.

- 슈퍼클래스를 위임으로 바꾸기
  - 상속을 잘못 적용한 예로 자바의 스택 클래스가 유명하다 - 자바의 스택은 리스트를 상속하고 있는데, 데이터를 저장하고 조작하는 리스트의 기능을 재활용하겠다는 생각이 초래한 결과다. 재활용 관점에서는 좋았지만 리스트의 연산 중 스택에는 적용되지 않는 게 많음에도 모든 연산이 스택 인터페이스에 그대로 노출된다. -> 스택에서 리스트 객체를 필드에 저장해두고 필요한 기능만 위임했다면 괜찮았을 것이다.
