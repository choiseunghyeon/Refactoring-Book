mocha ref: https://mochajs.org/#installation  
갱신되는 내용, 공지, 기타 정보 github: https://github.com/WegraLee/Refactoring

# Refactoring 책의 목표

- 리팩터링 원리와 좋은 리팩터링 습관을 설명한다.
- 언제 어떤 상황에 코드를 분석하고 개선해야 하는지 설명한다.
- 코드를 개선해야 하는 배경과 검증된 절차를 설명한다.

# Chapter 2. 리팩터링 원칙

## 리팩터링이란.

- 겉보기 동작은 유지하면서 코드를 이해하고 수정하기 쉽도록 내부 구조를 개선하는 방식

## 리팩터링하는 이유 81p.

- 소프트웨어 설계가 좋아진다.
  - 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. -> 설계 파악이 어려워진다. 따라서 리팩터링을 하여 기반 구조를 유지하거나 좋게만들어야 한다.
- 소프트웨어를 이해하기 쉬워진다.
  - 이해하기 쉬운 코드는 나 자신과 동료 개발자들을 위하는 것
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.
  - 잘 관리되지 않은 코드베이스에는 새로운 기능을 녹여내기 어렵고 버그가 잦다.
- 클린코드나 바람직한 엔지니어링 습관 같은 도덕적인 것이 아니라 오로지 경제적인 이유 때문이다.
  - 리팩터링으로 얻는 이점으로 설계가 좋아진다. / 이해하기 쉬워진다 / 버그를 쉽게 찾는다 / 프로그래밍 속도를 높인다는 기능 추가와 수정을 쉽게 해주므로 경제적이다.

## 언제 리팩터링해야 할까? 85p.

- 3의 법칙 (비슷한 일을 세 번 마주하면 리팩터링해야 할 때이다.)
- 준비를 위한 리팩터링
  - 리팩터링을 통해 기능 추가가 더 수월할 것 같을 때
  - 눈 앞에 보이는 숲을 가로질러 가는 것 보다 조금 돌아가더라도 고속도로를 타고 가는게 몇 배는 빠르다.
  - 잠깐 지도를 보고 가장 빠른 경로를 찾자.
- 이해를 위한 리팩터링
  - 깔끔하게 정리된 코드는 이전에 보이지 않던 설계가 눈에 들어온다. (새로운 설계에 도움)
  - 이해한 내용을 바로 코드에 반영
- 쓰레기 줍기 리팩터링
  - 코드가 비효율 적일 때 간단히 수정할 수 있다면 고친다. 아니라면 하던일을 마치고 처리한다.
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링은 프로그래밍 중 수시로 한다.
  - 단, 계획된 리팩터링이 무조건 나쁜건 아니기 때문에 소홀했던 부분을 작정하고 리팩터링 하는 것도 필요

## 리팩터링 하지 말아야 할 때

- 굳이 수정할 필요가 없다면
  - 코드를 수정할 일이 없고 이미 잘 사용되고 있고 성능에 문제가 없다면 할 필요 없다.
- 처음부터 새로 작성하는게 쉬울 때

## 리팩터링, 아키텍처, YAGNI - you aren't going to need it - 102p.

- 기존에는 코딩전에 요구사항을 파악하여 아키텍쳐를 확정하고 코딩을 했다. 하지만 요구사항은 수시로 변하기 때문에 사실상 불가능하다.
- 그렇다면 유연성 메커니즘을 소프트웨어에 심어서 해결할 수 있는가?
  - 함수를 만들 때 현재 파악된 요구사항을 만족만 하는 함수가 아니라 미래에 필요할 것 같은 요구사항도 만족하도록 만든다.
  - 결과적으로 유연성 메커니즘으로 인해 미래 요구사항 대응 능력을 떨어뜨리고 시스템을 더욱 복잡하게 만드는 요인이 된다.
- YAGNI
  - 현재 파악된 요구사항을 멋지게 반영하자.
  - 요구사항이 변하면 그때 리팩터링한다.
  - 나중에 문제를 이해하고 처리하는게 훨씬 낫다.
  - 자가 테스트 코드, 지속적 통합, 리팩터링은 YAGNI에 긍정적인 영향을 준다.

## 리팩터링과 성능

- 모든 부분에 성능을 고려하는 것은 낭비다.
- 대부분의 프로그램은 극히 일부분에서 대부분의 시간을 소모한다.
- 리팩터링된 코드는 튜닝하기 쉽다. 그렇다면 문제가 되는 부분을 찾아 해당 부분만 성능개선한다.
- 리팩터링을 하면 개발속도를 빠르게 유지하여 성능 향상에 집중할 시간을 준다.
- 성능분석을 세밀하게 할 수 있다.

## Tip

- 프로그램이 기능을 추가하기 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 기능을 추가하자.
- 조금씩 수정하여 피드백 주기를 짧게 가져가자. (수정 사항이 많다면 오류가 났을 때 확인할 부분이 많아서 결과적으로 작업 시간이 늘어난다.)
- 성능 문제는 특별한 경우가 아니라면 리팩토링 이후 시간을 내어 성능 개선을 하자.(리팩터링이 되면 성능 개선을 더욱 효과적으로 할 수 있다.)
- JS는 생성자가 서브클래스의 인스턴스를 반환할 수 없다. 따라서 생성자를 팩터리 함수로 바꾸기를 적용 한다. 70p.
- **_리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. 77p._**
- **_주석을 이용해 함수의 목적을 설명해 보면 함수의 좋은 이름을 떠올리는데 효과적이다._**
