mocha ref: https://mochajs.org/#installation  
갱신되는 내용, 공지, 기타 정보 github: https://github.com/WegraLee/Refactoring

# Refactoring 책의 목표

- 리팩터링 원리와 좋은 리팩터링 습관을 설명한다.
- 언제 어떤 상황에 코드를 분석하고 개선해야 하는지 설명한다.
- 코드를 개선해야 하는 배경과 검증된 절차를 설명한다.

# Chapter 2. 리팩터링 원칙

## 리팩터링이란.

- 겉보기 동작은 유지하면서 코드를 이해하고 수정하기 쉽도록 내부 구조를 개선하는 방식

## 리팩터링하는 이유 81p.

- 소프트웨어 설계가 좋아진다.
  - 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. -> 설계 파악이 어려워진다. 따라서 리팩터링을 하여 기반 구조를 유지하거나 좋게만들어야 한다.
- 소프트웨어를 이해하기 쉬워진다.
  - 이해하기 쉬운 코드는 나 자신과 동료 개발자들을 위하는 것
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.
  - 잘 관리되지 않은 코드베이스에는 새로운 기능을 녹여내기 어렵고 버그가 잦다.
- 클린코드나 바람직한 엔지니어링 습관 같은 도덕적인 것이 아니라 오로지 경제적인 이유 때문이다.
  - 리팩터링으로 얻는 이점으로 설계가 좋아진다. / 이해하기 쉬워진다 / 버그를 쉽게 찾는다 / 프로그래밍 속도를 높인다는 기능 추가와 수정을 쉽게 해주므로 경제적이다.

## 언제 리팩터링해야 할까? 85p.

- 3의 법칙 (비슷한 일을 세 번 마주하면 리팩터링해야 할 때이다.)
- 준비를 위한 리팩터링
  - 리팩터링을 통해 기능 추가가 더 수월할 것 같을 때
  - 눈 앞에 보이는 숲을 가로질러 가는 것 보다 조금 돌아가더라도 고속도로를 타고 가는게 몇 배는 빠르다.
  - 잠깐 지도를 보고 가장 빠른 경로를 찾자.
- 이해를 위한 리팩터링
  - 깔끔하게 정리된 코드는 이전에 보이지 않던 설계가 눈에 들어온다. (새로운 설계에 도움)
  - 이해한 내용을 바로 코드에 반영
- 쓰레기 줍기 리팩터링
  - 코드가 비효율 적일 때 간단히 수정할 수 있다면 고친다. 아니라면 하던일을 마치고 처리한다.
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링은 프로그래밍 중 수시로 한다.
  - 단, 계획된 리팩터링이 무조건 나쁜건 아니기 때문에 소홀했던 부분을 작정하고 리팩터링 하는 것도 필요

## 리팩터링 하지 말아야 할 때

- 굳이 수정할 필요가 없다면
  - 코드를 수정할 일이 없고 이미 잘 사용되고 있고 성능에 문제가 없다면 할 필요 없다.
- 처음부터 새로 작성하는게 쉬울 때

## 리팩터링, 아키텍처, YAGNI - you aren't going to need it - 102p.

- 기존에는 코딩전에 요구사항을 파악하여 아키텍쳐를 확정하고 코딩을 했다. 하지만 요구사항은 수시로 변하기 때문에 사실상 불가능하다.
- 그렇다면 유연성 메커니즘을 소프트웨어에 심어서 해결할 수 있는가?
  - 함수를 만들 때 현재 파악된 요구사항을 만족만 하는 함수가 아니라 미래에 필요할 것 같은 요구사항도 만족하도록 만든다.
  - 결과적으로 유연성 메커니즘으로 인해 미래 요구사항 대응 능력을 떨어뜨리고 시스템을 더욱 복잡하게 만드는 요인이 된다.
- YAGNI
  - 현재 파악된 요구사항을 멋지게 반영하자.
  - 요구사항이 변하면 그때 리팩터링한다.
  - 나중에 문제를 이해하고 처리하는게 훨씬 낫다.
  - 자가 테스트 코드, 지속적 통합, 리팩터링은 YAGNI에 긍정적인 영향을 준다.

## 리팩터링과 성능

- 모든 부분에 성능을 고려하는 것은 낭비다.
- 대부분의 프로그램은 극히 일부분에서 대부분의 시간을 소모한다.
- 리팩터링된 코드는 튜닝하기 쉽다. 그렇다면 문제가 되는 부분을 찾아 해당 부분만 성능개선한다.
- 리팩터링을 하면 개발속도를 빠르게 유지하여 성능 향상에 집중할 시간을 준다.
- 성능분석을 세밀하게 할 수 있다.

## Tip

- 프로그램이 기능을 추가하기 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 기능을 추가하자.
- 조금씩 수정하여 피드백 주기를 짧게 가져가자. (수정 사항이 많다면 오류가 났을 때 확인할 부분이 많아서 결과적으로 작업 시간이 늘어난다.)
- 성능 문제는 특별한 경우가 아니라면 리팩토링 이후 시간을 내어 성능 개선을 하자.(리팩터링이 되면 성능 개선을 더욱 효과적으로 할 수 있다.)
- JS는 생성자가 서브클래스의 인스턴스를 반환할 수 없다. 따라서 생성자를 팩터리 함수로 바꾸기를 적용 한다. 70p.
- **_리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. 77p._**

# Chapter 3. 코드에서 나는 악취 - 113p.

'적용 방법'을 아는 것과 '제때 적용'할 줄 아는 것은 다르다.  
리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.  
종료 시점은 숙련된 사람의 직관만큼 정확한 기준이 없기 때문에 리팩터링하면 해결할 수 있는 문제의 징후를 제시한다.  
(인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다.)

## 기이한 이름 - Mysterious Name

- 추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만 코드는 아니다. 코드는 단순하고 명료하게 작성해야 한다.
- **_코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나는 '이름'이다._**
- 이름만 잘 지어도 나중에 **_문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다._**
- 마땅한 이름이 떠오르지 않는다면 설계에 **_더 근본적인 문제가 숨어 있을 가능성이 높다._**
- 리팩토링 기법: 함수 선언 바꾸기(6.5절) / 변수 이름 바꾸기(6.7절) / 필드 이름 바꾸기(9.2절)

## 중복 코드 - Duplicated Code

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 코드 중복은 각 코드를 볼 때 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.
- 리팩토링 기법: 함수 추출하기(6.1절) / 문장 슬라이드하기(8.6절) / 메서드 올리기(12.1절)

## 긴 함수 - Long Function

- **_저자의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성되어 있다._**
- 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.
- 함수 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다.
- 코드가 단 한줄이어도 설명(주석)이 필요하다면 함수의 목적(의도)을 잘 설명할 수 있는 이름의 함수로 추출한다.
- 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.
- 반복문을 함수로 추출하고 적당한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있을 수 있다. 이럴 때는 반복문 쪼개기를 적용해서 작업을 분리한다.
- 리팩토링 기법: 함수 추출하기(6.1절) / 임시 변수를 질의 함수로 바꾸기(7.4절) / 매개변수 객체 만들기(6.8절) / 객체 통째로 넘기기(11.4절) / 함수를 명령으로 바꾸기(11.9절) / 조건문 분해하기(10.1절) / 조건문을 다형성으로 바꾸기(10.4절) / 반복문 쪼개기(8.7절)

## 긴 매개변수 목록 - Long Parameter List

- **_매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다._**
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데 이럴 때는 매개변수를 질의함수로 바꾸기(11.5절)로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기(11.4절)로 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 매개변수 객체만들기(6.8절)로 하나로 묶어버린다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기(11.3절)로 제거한다.
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용한다면 여러 함수를 클래스로 묶기(6.9절)로 공통 값들을 클래스의 필드로 정의한다.
- 리팩토링 기법: 매개변수를 질의함수로 바꾸기(11.5절) / 객체 통째로 넘기기(11.4절) / 매개변수 객체 만들기(6.8절) / 플래그 인수 제거하기(11.3절) / 여러 함수를 클래스로 묶기(6.9절)

## 전역 데이터 - Global Data

- **_전역 데이터는 코드베이스 어디서든 건드릴 수 있기 때문에 버그가 끊임없이 발생하는데 원인이 되는 코드를 찾아내기가 굉장히 어렵다._**
- 대표적으로 전역 변수가 있지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.
- 이를 방지하기 위해 변수 캡슐화하기 리팩터링을 수행할 수 있다.
- 리팩토링 기법: 변수 캡슐화하기(6.6절)

## 가변 데이터 - Mutable Data

- **_다른 곳에서 다른 값을 기대한다는 사실을 인식하지 못한 채 데이터가 변경되면 예상치 못한 결과나 버그로 이어지는 경우가 종종 있다._**
- 리팩토링 기법: 변수 캡슐화하기(6.6절) / 변수 쪼개기(9.1절) / 문장 슬라이드(8.6절)와 함수 추출하기(6.1절) / 질의 함수와 변경 함수 분리하기(11.1절) / 세터 제거하기(11.7절) / 파생 변수를 질의 함수로 바꾸기(9.3절) / 여러 함수를 클래스로 묶기(6.9절) / 여러 함수를 변환 함수로 묶기 (6.10절) / 참조를 값으로 바꾸기(9.4절)

## 뒤엉킨 변경 - Divergent Change

- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한군데를 찾아서 수정할 수 있기를 바란다. 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중 하나가 풍긴다.
- 뒤엉킨 변경은 단일 책임 원칙(SRP)이 제대로 지켜지지 않을 때 나타난다. (하나의 모듈이 서로 다른 이유들로 인해 변경되서는 안된다.)
- 지원해야 할 DB가 추가될 때 마다 함수 세 개를 바꿔야 하고, 금융 상품이 추가될 때 마다 또 다른 함수 네 개를 바꿔야 하는 모듈이 있다면 뒤엉킨 변경이 발생한다는 뜻이다.
- 리팩토링 기법: 단계 쪼개기(6.11절) / 함수 옮기기(8.1절) / 클래스 추출하기(7.5절)
- 디자인 패턴으로는 전략 패턴(Strategy Pattern) / 방문자 패턴(Visitor Pattern) 그리고 켄트 백의 자기 위임(Self-Delegation)이 해당 문제를 없앨 떄 활용한다.

## 산탄총 수술 - Shotgun Surgery

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- 리팩토링 기법: 함께 변경되는 대상들을 함수 옮기기(8.1절)와 필드 옮기기(8.2절)로 한 모듈에 묶어두면 좋다. / 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기(6.9절) / 데이터 구조를 변환하거나 보강(enrich)하는 함수들에는 여러 함수를 변환 함수로 묶기(6.10절) / 단계 쪼개기(6.11절) / 어설프레 분리된 로직은 함수 인라인하기(6.2절) 클래스 인라인하기(7.6절)

## 기능 편애 - Feature Envy

- 모듈화 할 때는 모듈 안 상호작용은 최대한 늘리고 모듈 간의 상호작용은 최소로 줄이는데 주력한다.
- 기능 편애는 어떤 함수가 자신이 속한 모듈 보다 다른 모듈의 함수나 데이터와 상호작용을 더 많이 하는 것이다.
- 리팩토링 기법: 함수 옮기기(8.1절)

## 데이터 뭉치 - Data Clumps

- 클래스 여러 곳의 필드 혹은 메서드의 시그니처에서 데이터 항목 서너 개가 뭉쳐다니는 모습을 흔히 볼 수 있다. 이런 경우 보금자리를 따로 마련해줘야 마땅하다.
- 값 하나를 삭제 했을 때 나머지 데이터만으로는 의미가 없다면 데이터 뭉치라는 뜻이다.
- 리팩토링 기법: 필드 형태의 데이터 뭉치를 찾아서 클래스 추출하기(7.5절)로 묶는다. / 메서드 시그니처에 있는 데이터 뭉치는 매개변수 객체 만들기(6.8절) 또는 객체 통째로 넘기기(11.4절)로 매개변수 수를 줄인다.

## 기본형 집착 - Primitive Obsession

- 기초 타입(화폐, 좌표, 구간 등)을 직접 정의하기 꺼려해서 금액을 숫자형으로 계산하거나 물리량을 계산할 때 단위를 무시하고 처리하는 코드가 많다.
- 문자열에서 특히 심한데 전화번호를 단순히 문자 집합으로 표현하기엔 아쉬움이 많다.
- 리팩토링 기법: 기본형을 객체로 바꾸기: (7.3절) / 조건부 동작을 제어하는 타입 코드로 쓰였다면 타입 코드를 서브클래스로 바꾸기(12.6절)와 조건부 로직을 다형성으로 바꾸기(10.4절)을 차례로 적용

## 반복되는 switch문 - Repeated Switches

- 중복되는 switch문의 경우 조건절 하나가 추가될 때 마다 다른 switch문들도 모두 수정해야 하기 때문에 다형성을 활용하자
- 리팩토링 기법: 조건부 로직을 다형성으로 바꾸기(10.4절)

## 반복문 - Loops

- 각 원소들이 어떻게 처리되는지 쉽게 처리하자.
- 리팩토링 기법: 반복문을 파이프라인으로 바꾸기(8.8절)

## 성의 없는 요소 - Lazy Element

- 필요 없어진 구조는 제거하자.
- 리팩토링 기법: 함수 인라인하기(6.2절) / 클래스 인라인하기(7.6절) / 계층 합치기(12.9절)

## 추측성 일반화 - Speculative Generality

- 나중에 필요하다고 생각하여 후킹 포인트, 특이 케이스 처리 로직을 작성해둔 코드에서 풍긴다. 결과적으로 이해하거나 관리하기 어렵다.
- 리팩토링 기법: 하는 일이 거의 없는 추상 클래스는 계층 합치기(12.9절) / 쓸데없이 위임하는 코드는 함수 인라인하기(6.2절) 또는 클래스 인라인하기(7.6절) / 사용되지 않는 매개변수는 함수 선언 바꾸기(6.5절) / 죽은 코드 제거하기(8.9절)

## 임시 필드 - Temporary Field

- 객체를 가져올 때 모든 필드가 채워져 있으리라 기대하는게 보통이라, 특정 상황에서만 값이 설정되는 임시 필드는 코드를 이해하기 어렵게 만든다.
- 리팩토링 기법: 클래스 추출하기(7.5절)와 함수 옮기기(8.1절)로 임시 필드들과 관련된 코드를 새 클래스에 몰아넣는다. / 임시 필드들이 유효한지 확인 후 동작하는 조건부 로직이 있을 수 있는데 특이 케이스 추가하기(10.5절)로 필드들이 유효하지 않을 때를 위한 대안 클래스를 만들어서 제거할 수 있다.

## 메시지 체인 - Message Chains

- 메시지 체인은 클라이언트가 한 객체를 통해 다른 객체를 얻고 또 다른 객체를 요청하는 식으로 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.
- 이는 클라이언트가 객체 내비게이션 구조에 종속되므로 내비게이션 중간 단계를 수정하면 클라이언트 코드도 수정해야 한다.
- 리팩토링 기법: 위임 숨기기(7.7절)는 메시지 체인의 다양한 연결점에 적용할 수 있다. / 함수 추출하기(6.1절)로 결과 객체를 사용하는 코드 일부를 따로 빼낸 다음 함수 옮기기(8.1절)로 체인을 숨길 수 있는지 살펴보자.

## 중개자 - Middle Man

- 객체의 대표적 기능으로 캡슐화가 있는데 캡슐화 하는 과정에서 위임이 자주 활용된다.
- 리팩토링 기법: 지나치면 문제가 되므로 클래스가 제공하는 메서드 중 절반이 다른 클래스 구현을 위임하고 있다면 중개자 제거하기(7.8절)을 활용하자.

## 내부자 거래 - Insider Trading

- 리팩토링 기법: 여러 모듈이 같은 관심사를 공유한다면 공통 부분을 정식으로 처리하는 제 3의 모듈을 새로 만들거나 위임 숨기기(7.7절)을 이용하여 다른 모듈이 중간자 역할을 하게 한다. / 상속 구조에서 부모 자식 사이에 결탁이 생긴다면 서브클래스를 위임으로 바꾸기(12.10절) 또는 슈퍼클래스를 위임으로 바꾸기(12.11절)을 활용

## 거대한 클래스 - Large Class

- 한 클래스가 많은 일을 하려다 보면 필드 수가 늘어나고 중복 코드도 생기기 쉽다.
- 리팩토링 기법: 클래스 추출하기(7.5절) depositAmount와 depositCurrency처럼 접두어나 접미어가 같은 필드들이 함께 추출될 후보들이다. 또는 클라이언트들이 클래스의 특정 기능 그룹만 사용하는것과 같이 패턴을 파악하여 어떻게 쪼갤지 단서를 얻을 수도 있다. / 만약 상속 관계가 더 괜찮다면 슈퍼 클래스 추출하기(12.8절) 또는 타입 코드를 서브클래스로 바꾸기(12.6절)을 적용하는 편이 쉽다.

## 서로 다른 인터페이스의 대안 클래스들 - Alternative Classes with Different Interfaces

- 클래스 사용의 큰 장점은 언제든 다른 클래스로 교체할 수 있다는 것이다만, 인터페이스가 같아야한다.
- 리팩토링 기법: 함수 선언 바꾸기(6.5절)로 메서드 시그니처를 일치 / 부족하다면 함수 옮기기(8.1절)로 인터페이스가 같아질 때 까지 필요한 동작을 클래스에 넣는다. / 중복 코드가 생기면 슈퍼클래스 추출하기(12.8절)를 고려해본다.

## 데이터 클래스 - Data Class

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다.
- 데이터 저장용도로만 쓰이다 보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.
- 필요한 동작이 엉뚱한 곳에 정의돼 있다는 신호일 수 있다.
- 리팩토링 기법: public 필드가 있다면 레코드 캡슐화하기(7.1절)로 숨기자. / 변경하면 안 되는 필드는 세터 제거하기(11.7절) / 다른 클래스에서 데이터 클래스의 게터/세터를 사용하는 메서드를 찾아서 함수 옮기기(8.1절) 또는 함수 추출하기(6.1절)이용해서 옮긴다.

## 상속 포기 - Refused Bequest

- 서브 클래스는 부모로부터 메서드와 데이터를 물려받는다. 하지만 부모의 유산을 원치 않거나 일부만 받고 싶다면?
- 상속 포기 냄새는 서브클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 특히 심하게 난다.
- 리팩토링 기법: 먼저 같은 계층에 서브 클래스를 하나 새로 만들고, 메서드 내리기(12.4절)와 필드 내리기(12.5절)로 물려받지 않을 부모 코드를 모조리 새로 만든 서브클래스로 넘긴다. 그러면 부모에는 공통된 부분만 남는다. / 인터페이스를 따르고 싶지 않은 경우 서브클래스를 위임으로 바꾸기(12.10절) 또는 슈퍼클래스를 위임으로 바꾸기(12.11절)을 활용하여 상속 메커니즘에서 벗아나자.

## 주석 - Comments

- 사실 주석은 악취가 아닌 향기지만 간혹 탈취제처럼 사용하는 경우가 있다.
- 주석이 길게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 이렇다.
- 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링 해본다.
- 리팩토링 기법: 함수 추출하기(6.1절) / 함수 선언 바꾸기(6.5절) / 어서션 추가하기(10.6절)
