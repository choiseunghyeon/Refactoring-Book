mocha ref: https://mochajs.org/#installation
갱신되는 내용, 공지, 기타 정보 github: https://github.com/WegraLee/Refactoring

# Refactoring 책의 목표

- 리팩터링 원리와 좋은 리팩터링 습관을 설명한다.
- 언제 어떤 상황에 코드를 분석하고 개선해야 하는지 설명한다.
- 코드를 개선해야 하는 배경과 검증된 절차를 설명한다.

# Chapter 2. 리팩터링 원칙

## 리팩터링이란.

- 겉보기 동작은 유지하면서 코드를 이해하고 수정하기 쉽도록 내부 구조를 개선하는 방식

## 리팩터링하는 이유 81p.

- 소프트웨어 설계가 좋아진다.
  - 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다. -> 설계 파악이 어려워진다. 따라서 리팩터링을 하여 기반 구조를 유지하거나 좋게만들어야 한다.
- 소프트웨어를 이해하기 쉬워진다.
  - 이해하기 쉬운 코드는 나 자신과 동료 개발자들을 위하는 것
- 버그를 쉽게 찾을 수 있다.
- 프로그래밍 속도를 높일 수 있다.
  - 잘 관리되지 않은 코드베이스에는 새로운 기능을 녹여내기 어렵고 버그가 잦다.
- 클린코드나 바람직한 엔지니어링 습관 같은 도덕적인 것이 아니라 오로지 경제적인 이유 때문이다.
  - 리팩터링으로 얻는 이점으로 설계가 좋아진다. / 이해하기 쉬워진다 / 버그를 쉽게 찾는다 / 프로그래밍 속도를 높인다는 기능 추가와 수정을 쉽게 해주므로 경제적이다.

## 언제 리팩터링해야 할까? 85p.

- 3의 법칙 (비슷한 일을 세 번 마주하면 리팩터링해야 할 때이다.)
- 준비를 위한 리팩터링
  - 리팩터링을 통해 기능 추가가 더 수월할 것 같을 때
  - 눈 앞에 보이는 숲을 가로질러 가는 것 보다 조금 돌아가더라도 고속도로를 타고 가는게 몇 배는 빠르다.
  - 잠깐 지도를 보고 가장 빠른 경로를 찾자.
- 이해를 위한 리팩터링
  - 깔끔하게 정리된 코드는 이전에 보이지 않던 설계가 눈에 들어온다. (새로운 설계에 도움)
  - 이해한 내용을 바로 코드에 반영
- 쓰레기 줍기 리팩터링
  - 코드가 비효율 적일 때 간단히 수정할 수 있다면 고친다. 아니라면 하던일을 마치고 처리한다.
- 계획된 리팩터링과 수시로 하는 리팩터링
  - 리팩터링은 프로그래밍 중 수시로 한다.
  - 단, 계획된 리팩터링이 무조건 나쁜건 아니기 때문에 소홀했던 부분을 작정하고 리팩터링 하는 것도 필요

## 리팩터링 하지 말아야 할 때

- 굳이 수정할 필요가 없다면
  - 코드를 수정할 일이 없고 이미 잘 사용되고 있고 성능에 문제가 없다면 할 필요 없다.
- 처음부터 새로 작성하는게 쉬울 때

## 리팩터링, 아키텍처, YAGNI - you aren't going to need it - 102p.

- 기존에는 코딩전에 요구사항을 파악하여 아키텍쳐를 확정하고 코딩을 했다. 하지만 요구사항은 수시로 변하기 때문에 사실상 불가능하다.
- 그렇다면 유연성 메커니즘을 소프트웨어에 심어서 해결할 수 있는가?
  - 함수를 만들 때 현재 파악된 요구사항을 만족만 하는 함수가 아니라 미래에 필요할 것 같은 요구사항도 만족하도록 만든다.
  - 결과적으로 유연성 메커니즘으로 인해 미래 요구사항 대응 능력을 떨어뜨리고 시스템을 더욱 복잡하게 만드는 요인이 된다.
- YAGNI
  - 현재 파악된 요구사항을 멋지게 반영하자.
  - 요구사항이 변하면 그때 리팩터링한다.
  - 나중에 문제를 이해하고 처리하는게 훨씬 낫다.
  - 자가 테스트 코드, 지속적 통합, 리팩터링은 YAGNI에 긍정적인 영향을 준다.

## 리팩터링과 성능

- 모든 부분에 성능을 고려하는 것은 낭비다.
- 대부분의 프로그램은 극히 일부분에서 대부분의 시간을 소모한다.
- 리팩터링된 코드는 튜닝하기 쉽다. 그렇다면 문제가 되는 부분을 찾아 해당 부분만 성능개선한다.
- 리팩터링을 하면 개발속도를 빠르게 유지하여 성능 향상에 집중할 시간을 준다.
- 성능분석을 세밀하게 할 수 있다.

## Tip

- 프로그램이 기능을 추가하기 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 기능을 추가하자.
- 조금씩 수정하여 피드백 주기를 짧게 가져가자. (수정 사항이 많다면 오류가 났을 때 확인할 부분이 많아서 결과적으로 작업 시간이 늘어난다.)
- 성능 문제는 특별한 경우가 아니라면 리팩토링 이후 시간을 내어 성능 개선을 하자.(리팩터링이 되면 성능 개선을 더욱 효과적으로 할 수 있다.)
- JS는 생성자가 서브클래스의 인스턴스를 반환할 수 없다. 따라서 생성자를 팩터리 함수로 바꾸기를 적용 한다. 70p.
- **_리팩터링을 효과적으로 하는 핵심은, 단계를 잘게 나눠야 더 빠르게 처리할 수 있고, 코드는 절대 깨지지 않으며, 이러한 작은 단계들이 모여서 상당히 큰 변화를 이룰 수 있다는 사실을 깨닫는 것이다. 77p._**

# Chapter 3. 코드에서 나는 악취 - 113p.

'적용 방법'을 아는 것과 '제때 적용'할 줄 아는 것은 다르다.  
리팩터링을 언제 시작하고 언제 그만할지를 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지않게 중요하다.  
종료 시점은 숙련된 사람의 직관만큼 정확한 기준이 없기 때문에 리팩터링하면 해결할 수 있는 문제의 징후를 제시한다.  
(인스턴스 변수는 몇 개가 적당한지, 메서드가 몇 줄을 넘어가면 안 좋은지 등은 각자 경험을 통해 감을 키워야 한다.)

## 기이한 이름 - Mysterious Name

- 추리 소설이라면 무슨 일이 전개되는지 궁금증을 자아낼수록 좋겠지만 코드는 아니다. 코드는 단순하고 명료하게 작성해야 한다.
- **_코드를 명료하게 표현하는 데 가장 중요한 요소 중 하나는 '이름'이다._**
- 이름만 잘 지어도 나중에 **_문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다._**
- 마땅한 이름이 떠오르지 않는다면 설계에 **_더 근본적인 문제가 숨어 있을 가능성이 높다._**

## 중복 코드 - Duplicated Code

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 코드 중복은 각 코드를 볼 때 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다.

## 긴 함수 - Long Function

- **_저자의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 짧은 함수로 구성되어 있다._**
- 간접 호출(indirection)의 효과, 즉 코드를 이해하고, 공유하고, 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나온다.
- 함수 이름은 동작 방식이 아닌 '의도(intention)'가 드러나게 짓는다.
- 코드가 단 한줄이어도 설명(주석)이 필요하다면 함수의 목적(의도)을 잘 설명할 수 있는 이름의 함수로 추출한다.
- 즉, '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리하다.
- 반복문을 함수로 추출하고 적당한 이름이 떠오르지 않는다면 성격이 다른 두 가지 작업이 섞여 있을 수 있다. 이럴 때는 반복문 쪼개기를 적용해서 작업을 분리한다.

## 긴 매개변수 목록 - Long Parameter List

- **_매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많다._**
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수가 있을 수 있는데 이럴 때는 매개변수를 질의함수로 바꾸기(11.5절)로 제거할 수 있다.
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드라면 객체 통째로 넘기기(11.4절)로 원본 데이터 구조를 그대로 전달한다.
- 항상 함께 전달되는 매개변수들은 매개변수 객체만들기(6.8절)로 하나로 묶어버린다.
- 함수의 동작 방식을 정하는 플래그 역할의 매개변수는 플래그 인수 제거하기(11.3절)로 제거한다.
- 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용한다면 여러 함수를 클래스로 묶기(6.9절)로 공통 값들을 클래스의 필드로 정의한다.
